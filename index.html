<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üçΩÔ∏è Hardcore AR Food Menu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body, html {
      margin: 0; padding: 0; overflow: hidden; font-family: 'Arial', sans-serif;
      background: #000;
      color: white;
      user-select: none;
      -webkit-user-select: none;
    }
    #infoPanel {
      position: absolute;
      top: 10px; left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
      max-width: 320px;
    }
    button {
      font-size: 1rem;
      margin-top: 10px;
      padding: 8px 12px;
      background: #ff6600;
      border: none;
      color: white;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background: #ff8533;
    }
  </style>
</head>
<body>

<div id="infoPanel">
  <h2>Choose your dish</h2>
  <button onclick="loadDish('https://models.example.com/burger.glb', 'Burger', 'Calories: 450', '$8.99', 4.5)">üçî Burger</button>
  <button onclick="loadDish('https://models.example.com/pizza.glb', 'Pizza', 'Calories: 700', '$12.99', 4.7)">üçï Pizza</button>
  <button onclick="loadDish('https://models.example.com/pasta.glb', 'Pasta', 'Calories: 550', '$10.99', 4.6)">üçù Pasta</button>
  <p><small>Tap on your choice and then scan your surroundings!</small></p>
</div>

<script type="module">

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';
import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/webxr/ARButton.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/loaders/GLTFLoader.js';

let container;
let camera, scene, renderer;
let controller;
let reticle;
let model = null;
let infoGroup;
let loadedDish = null;

init();

function init() {
  container = document.createElement('div');
  document.body.appendChild(container);

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

  // Lighting
  const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
  light.position.set(0.5, 1, 0.25);
  scene.add(light);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  container.appendChild(renderer.domElement);

  // AR Button
  document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

  // Controller for hit testing
  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  // Reticle for surface detection
  reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.07, 0.1, 32).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({ color: 0xff6600 })
  );
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // Group to hold model + info overlays
  infoGroup = new THREE.Group();
  scene.add(infoGroup);

  window.addEventListener('resize', onWindowResize, false);

  renderer.setAnimationLoop(render);
}

// When user taps on detected surface to place the model
function onSelect() {
  if (reticle.visible && loadedDish) {
    // Place model + info group at reticle position
    infoGroup.position.setFromMatrixPosition(reticle.matrix);
    infoGroup.visible = true;
  }
}

function loadDish(modelUrl, name, nutrition, price, rating) {
  loadedDish = { modelUrl, name, nutrition, price, rating };
  infoGroup.visible = false;

  // Clear previous model/info
  while(infoGroup.children.length) {
    let child = infoGroup.children[0];
    child.geometry?.dispose();
    if(child.material) {
      if(Array.isArray(child.material)) {
        child.material.forEach(m => m.dispose());
      } else {
        child.material.dispose();
      }
    }
    infoGroup.remove(child);
  }

  // Load GLTF Model
  const loader = new GLTFLoader();
  loader.load(modelUrl, gltf => {
    model = gltf.scene;
    model.scale.set(0.3, 0.3, 0.3);
    infoGroup.add(model);

    // Add floating 3D text for info
    add3DText(name, 0, 0.5, 0);
    add3DText(nutrition, 0, 0.3, 0);
    add3DText(price, 0, 0.1, 0);
    add3DText(`‚≠ê ${rating}`, 0, -0.1, 0);

    alert("Now tap on a flat surface to place your dish!");
  }, undefined, e => {
    alert("Failed to load 3D model: " + e.message);
  });
}

function add3DText(text, x, y, z) {
  // For quick demo, use THREE.js built-in TextGeometry requires loading font, which is bulky.
  // Instead, use simple sprites as text placeholders

  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 64;
  ctx.font = '30px Arial';
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.fillText(text, 128, 48);

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(material);
  sprite.position.set(x, y, z);
  sprite.scale.set(0.5, 0.125, 1);
  infoGroup.add(sprite);
}

function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function render(timestamp, frame) {
  if(frame) {
    const referenceSpace = renderer.xr.getReferenceSpace();
    const session = renderer.xr.getSession();

    if(session && referenceSpace) {
      // Hit test source requested once
      if(!hitTestSourceRequested) {
        session.requestReferenceSpace('viewer').then((refSpace) => {
          session.requestHitTestSource({ space: refSpace }).then(source => {
            hitTestSource = source;
          });
        });
        session.addEventListener('end', () => {
          hitTestSourceRequested = false;
          hitTestSource = null;
        });
        hitTestSourceRequested = true;
      }
      // Perform hit test
      if(hitTestSource) {
        const hitTestResults = frame.getHitTestResults(hitTestSource);
        if(hitTestResults.length) {
          const hit = hitTestResults[0];
          const pose = hit.getPose(referenceSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      }
    }
  }

  renderer.render(scene, camera);
}

let hitTestSource = null;
let hitTestSourceRequested = false;

</script>

</body>
</html>
